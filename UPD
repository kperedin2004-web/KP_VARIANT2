#pragma config OSC    = HS
#pragma config WDT    = OFF
#pragma config LVP    = OFF
#pragma config MCLRE  = ON
#pragma config PBADEN = OFF
#pragma config FCMEN  = OFF
#pragma config IESO   = OFF
#pragma config PWRT   = ON
#pragma config BOREN  = OFF

#include <xc.h>
#include <stdint.h>

#define _XTAL_FREQ      20000000UL
#define UART_BAUDRATE   9600
#define RX_BUFFER_SIZE  32
#define PWM_MAX_VALUE   255

#define LED_RED         LATAbits.LATA0
#define LED_GREEN       LATAbits.LATA1
#define LED_BLUE        LATAbits.LATA2

volatile uint8_t g_pwmDutyRed   = 0;
volatile uint8_t g_pwmDutyGreen = 0;
volatile uint8_t g_pwmDutyBlue  = 0;
volatile uint8_t g_pwmCounter = 0;
volatile char    g_rxBuffer[RX_BUFFER_SIZE];
volatile uint8_t g_rxIndex = 0;
volatile uint8_t g_lineReady = 0;

void __interrupt(high_priority) ISR_HighPriority(void) {
    if (PIR1bits.RCIF && PIE1bits.RCIE) {
        if (RCSTAbits.OERR) {
            RCSTAbits.CREN = 0;
            RCSTAbits.CREN = 1;
            return;
        }
        if (RCSTAbits.FERR) {
            volatile char dummy = RCREG;
            (void)dummy;
            return;
        }
        
        char receivedChar = RCREG;
        if (receivedChar == '\r' || receivedChar == '\n') {
            if (g_rxIndex > 0 && !g_lineReady) {
                g_rxBuffer[g_rxIndex] = '\0';
                g_lineReady = 1;
            }
        }
        else {
            if (g_rxIndex < RX_BUFFER_SIZE - 1 && !g_lineReady) {
                g_rxBuffer[g_rxIndex++] = receivedChar;
            }
        }
    }
}

void __interrupt(low_priority) ISR_LowPriority(void) {
    if (PIR1bits.TMR2IF && PIE1bits.TMR2IE) {
        PIR1bits.TMR2IF = 0;
        g_pwmCounter++;
        LED_RED   = (g_pwmCounter < g_pwmDutyRed)   ? 1 : 0;
        LED_GREEN = (g_pwmCounter < g_pwmDutyGreen) ? 1 : 0;
        LED_BLUE  = (g_pwmCounter < g_pwmDutyBlue)  ? 1 : 0;
    }
}

static void UART_Initialize(void) {
    TRISCbits.TRISC6 = 0;
    TRISCbits.TRISC7 = 1;
    SPBRG  = 129;
    SPBRGH = 0;
    TXSTA = 0b00100100;
    RCSTA = 0b10010000;
}

static void UART_TransmitChar(char c) {
    while (!TXSTAbits.TRMT);
    TXREG = c;
}

static void UART_TransmitString(const char *str) {
    while (*str) {
        UART_TransmitChar(*str++);
    }
}

static void UART_TransmitNumber(uint8_t value) {
    if (value >= 100) {
        UART_TransmitChar('0' + value / 100);
    }
    if (value >= 10) {
        UART_TransmitChar('0' + (value / 10) % 10);
    }
    UART_TransmitChar('0' + value % 10);
}

static void Timer2_Initialize(void) {
    T2CON = 0b00000101;
    PR2 = 77;
    TMR2 = 0;
}

static uint8_t Command_Parse(const char *str, uint8_t *r, uint8_t *g, uint8_t *b) {
    uint16_t currentValue = 0;
    uint8_t  valueCount   = 0;
    uint8_t  values[3]    = {0, 0, 0};
    uint8_t  inNumber     = 0;
    
    while (*str) {
        if (*str >= '0' && *str <= '9') {
            currentValue = currentValue * 10 + (*str - '0');
            if (currentValue > PWM_MAX_VALUE) {
                currentValue = PWM_MAX_VALUE;
            }
            inNumber = 1;
        }
        else {
            if (inNumber && valueCount < 3) {
                values[valueCount++] = (uint8_t)currentValue;
                currentValue = 0;
                inNumber = 0;
            }
        }
        str++;
    }
    
    if (inNumber && valueCount < 3) {
        values[valueCount++] = (uint8_t)currentValue;
    }
    
    if (valueCount == 3) {
        *r = values[0];
        *g = values[1];
        *b = values[2];
        return 1;
    }
    
    return 0;
}

static void Command_Process(void) {
    char localBuffer[RX_BUFFER_SIZE];
    uint8_t i;
    
    INTCONbits.GIE = 0;
    for (i = 0; i < RX_BUFFER_SIZE; i++) {
        localBuffer[i] = g_rxBuffer[i];
        if (localBuffer[i] == '\0') break;
    }
    g_rxIndex   = 0;
    g_lineReady = 0;
    INTCONbits.GIE = 1;
    
    uint8_t red, green, blue;
    if (Command_Parse(localBuffer, &red, &green, &blue)) {
        g_pwmDutyRed   = red;
        g_pwmDutyGreen = green;
        g_pwmDutyBlue  = blue;
        
        UART_TransmitString("OK: R=");
        UART_TransmitNumber(red);
        UART_TransmitString(" G=");
        UART_TransmitNumber(green);
        UART_TransmitString(" B=");
        UART_TransmitNumber(blue);
        UART_TransmitString("\r\n");
    }
    else {
        UART_TransmitString("ERROR: format R G B (0-255)\r\n");
    }
}

static void GPIO_Initialize(void) {
    ADCON1 = 0x0F;
    CMCON  = 0x07;
    TRISA = 0x00;
    LATA  = 0x00;
}

static void Interrupts_Initialize(void) {
    RCONbits.IPEN = 1;
    IPR1bits.RCIP  = 1;
    PIR1bits.RCIF  = 0;
    PIE1bits.RCIE  = 1;
    IPR1bits.TMR2IP = 0;
    PIR1bits.TMR2IF = 0;
    PIE1bits.TMR2IE = 1;
    INTCONbits.GIEL = 1;
    INTCONbits.GIEH = 1;
}

void main(void) {
    GPIO_Initialize();
    UART_Initialize();
    Timer2_Initialize();
    Interrupts_Initialize();
    
    while (1) {
        if (g_lineReady) {
            Command_Process();
        }
    }
}
